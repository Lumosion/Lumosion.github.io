
<!DOCTYPE html>
<html lang="cn">
    <head>
        <meta charset="utf-8" />
        <title>数论 | LumosionのBlog</title>
        <meta name="author" content="Lumosion" />
        <meta name="description" content="" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.3.4/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.4.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.8.0/highlight.min.js"></script>
<script src="https://cdn.staticfile.org/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.8.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.8/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.8/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    <body>
        <div id="layout">
            <transition name="fade">
                <div id="loading" v-show="loading">
                    <div id="loading-circle">
                        <h2>LOADING</h2>
                        <p>加载过慢请开启缓存 浏览器默认开启</p>
                        <img src="/images/loading.gif" />
                    </div>
                </div>
            </transition>
            <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>LUMOSIONのBLOG</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;主页</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;文章</span>
        </a>
        
        <a target="_blank" rel="noopener" href="https://lumosion.studio">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Lumosion</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;LUMOSIONのBLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">主页</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">文章</div>
                    </div>
                </a>
                
                <a target="_blank" rel="noopener" href="https://lumosion.studio">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Lumosion</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

            <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
                <div class="article">
    <div>
        <h1>数论</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2023/8/29
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/Math/" style="color: #00a596">Math</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/XCPC/" style="color: #ff7d73">XCPC</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <p>高精度、快速幂、GVD、质数、筛法、同余式、线性方程、组合数、容斥原理、生成函数</p>
<span id="more"></span>

<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="余数转写"><a href="#余数转写" class="headerlink" title="余数转写"></a>余数转写</h3><p> $\begin{aligned} k % i &#x3D;k-i*\lfloor\frac{k}{i}\rfloor\end{aligned}$ </p>
<h3 id="二进制倍增"><a href="#二进制倍增" class="headerlink" title="二进制倍增"></a>二进制倍增</h3><p> $l&lt;&lt;&#x3D;1$ </p>
<h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><p>二进制考虑，按位求解</p>
<h3 id="高斯素数"><a href="#高斯素数" class="headerlink" title="高斯素数"></a>高斯素数</h3><p>&#x2F;&#x2F;</p>
<h3 id="二项式反演"><a href="#二项式反演" class="headerlink" title="二项式反演"></a>二项式反演</h3><p><strong>二项式定理</strong>：$(a+b)^n&#x3D;\sum_{i&#x3D;0}^{n}{C_{n}^{i}a^{n-1}b^i}$；</p>
<h3 id="费马平方和定理"><a href="#费马平方和定理" class="headerlink" title="费马平方和定理"></a>费马平方和定理</h3><p>平方分解数的积是平方分解数。</p>
<p>$( a ^ { 2 } + b ^ { 2 } ) ( p ^ { 2 } + q ^ { 2 } ) &#x3D; ( a p + b q ) ^ { 2 } + ( a q - b p ) ^ { 2 } &#x3D; ( a p - b q ) ^ { 2 } + ( a q + b p ) ^ { 2 }$ </p>
<p>平方分解数被素平方分解数整除的商是平方分解数。</p>
<p>$( a p + b q ) ( a p - b q ) &#x3D; a ^ { 2 } p ^ { 2 } - b ^ { 2 } q ^ { 2 } &#x3D; a ^ { 2 } ( p ^ { 2 } + q ^ { 2 } ) - q ^ { 2 } ( a ^ { 2 } + b ^ { 2 } )$</p>
<p>平方分解数被非平方分解数整除的商必有一个非平方分解因子。</p>
<p>如果 $a$ 和 $b$ 互素，则 $a^2+b^2$ 的所有因子都是平方分解数。</p>
<p>形如 $4k+1$ 的素数是平方分解数。</p>
<p>形如 $4k+3$ 的素数<strong>不</strong>是平方分解数。</p>
<h3 id="镜面操作"><a href="#镜面操作" class="headerlink" title="镜面操作"></a>镜面操作</h3><p>&#x2F;&#x2F;</p>
<h3 id="p-进数"><a href="#p-进数" class="headerlink" title="$p$ 进数"></a>$p$ 进数</h3><p>&#x2F;&#x2F;</p>
<h3 id="Monsky定理"><a href="#Monsky定理" class="headerlink" title="Monsky定理"></a>Monsky定理</h3><p>一个正方形不可能被分割成奇数个面积相等的三角形。</p>
<h3 id="群论与数"><a href="#群论与数" class="headerlink" title="群论与数"></a>群论与数</h3><p>加法-&gt;平移</p>
<p>乘法-&gt;伸缩</p>
<p>虚数-&gt;旋转</p>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><h3 id="高精度加减乘除"><a href="#高精度加减乘除" class="headerlink" title="高精度加减乘除"></a>高精度加减乘除</h3><pre><code class="C++">const int N = 1e5;   //最大容量
string a, b;    // 输入字符串
int la, lb, lc; // a,b,c长度
int A[N] = &#123;0&#125;, B[N] = &#123;0&#125;, C[N] = &#123;0&#125;;
void add(int A[], int B[], int C[]) // 加
&#123;
    for (int i = 0; i &lt; lc; i++)
    &#123;
        C[i] += A[i] + B[i];
        C[i + 1] += (C[i] / 10);
        C[i] %= 10;
    &#125;
&#125;
bool cmp(int A[], int B[]) // 比较大小
&#123;
    if (la != lb)
        return la &gt; lb;
    else
        for (int i = la - 1; ~i; i--)
            if (A[i] != B[i])
                return A[i] &gt; B[i];
    return 1; // 相等返回1,避免结果为-0
&#125;
void sub(int A[], int B[], int C[]) // 减法，使用了比较大小cmp
&#123;
    if (!cmp(A, B))
        cout &lt;&lt; &quot;-&quot;, swap(A, B);
    for (int i = 0; i &lt; lc; i++)
    &#123;
        if (A[i] &lt; B[i])
            A[i] += 10, A[i + 1]--; // 借位
        C[i] = A[i] - B[i];         // 存差
    &#125;
    while (lc &amp;&amp; C[lc] == 0) // 前导零
        lc--;
    lc++;
&#125;
void mul(int A[], int B[], int C[]) // 乘法
&#123;
    for (int i = 0; i &lt; la; i++)
        for (int j = 0; j &lt; lb; j++)
        &#123;
            C[i + j] += A[i] * B[j];       // 累加乘积
            C[i + j + 1] += C[i + j] / 10; // 进位
            C[i + j] %= 10;                // 存余
        &#125;
    while (lc &amp;&amp; C[lc] == 0) // 前导零
        lc--;
    lc++;
&#125;
void div(int A[], int b, int C[]) // 除法，b为int以内
&#123;
    long long temp = 0; // 临时被除数
    for (int i = la - 1; ~i; i--)
    &#123;
        temp = temp * 10 + A[i]; // 临时被除数
        C[i] = temp / b;         // 存商
        temp %= b;               // 余数
    &#125;
    while (lc &amp;&amp; C[lc] == 0) // 前导零
        lc--;
    lc++;
&#125;
void Input(int A[]) // 转化字符串A
&#123;
    for (int i = 0; i &lt; la; i++)
        A[la - i - 1] = a[i] - &#39;0&#39;;
&#125;
void Output(int C[])
&#123;
    for (int i = lc - 1; ~i; i--)
        cout &lt;&lt; C[i];
&#125;
</code></pre>
<h3 id="高精度取模（秦九韶算法）"><a href="#高精度取模（秦九韶算法）" class="headerlink" title="高精度取模（秦九韶算法）"></a>高精度取模（秦九韶算法）</h3><pre><code class="C++">string s; // 输入的大数字
int mod(int p) // 对p取模
&#123;
    int res = 0;
    for (int i = 0; s[i]; i++)
    &#123;
        res = res * 10 + (s[i] - &#39;0&#39;);
        if (res &gt;= p)
            res %= p;
    &#125;
    return res;
&#125;
</code></pre>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><h3 id="快速幂-快速幂取模"><a href="#快速幂-快速幂取模" class="headerlink" title="快速幂 快速幂取模"></a>快速幂 快速幂取模</h3><pre><code class="C++">long long quickpow(long long a, long long n) // 快速幂 a^n
&#123;
    int res = 1;
    while (n)
    &#123;
        if (n &amp; 1)
            res = res * a;
        a = a * a, n &gt;&gt;= 1;
    &#125;
    return res;
&#125;
long long quickpowmodp(long long a, long long n, long long p) // 快速幂取模 a^n%p
&#123;
    int res = 1;
    while (n)
    &#123;
        if (n &amp; 1)
            res = res * a % p;
        a = a * a % p, n &gt;&gt;= 1;
    &#125;
    return res;
&#125;
</code></pre>
<h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><pre><code class="C++">/*求矩阵a的k次方*/
long long n, k;
const int N = 500;
const int mod = 1000000007;
struct Matrix // 定义矩阵a, res
&#123;
    long long c[N][N] = &#123;0&#125;;
&#125; a, res;
Matrix operator*(Matrix &amp;x, Matrix &amp;y) // 矩阵乘法
&#123;
    Matrix t; // 临时矩阵
    for (int i = 1; i &lt;= n; i++)
        for (int j = 1; j &lt;= n; j++)
            for (int k = 1; k &lt;= n; k++) // x的列数，y的行数必须相等，内层效率高
                t.c[i][j] = (t.c[i][j] + x.c[i][k] * y.c[k][j]) % mod;
    return t;
&#125;
void quickpow(long long k) // 快速幂
&#123;
    for (int i = 1; i &lt;= n; i++)
        res.c[i][i] = 1; // 单位矩阵
    while (k)
    &#123;
        if (k &amp; 1)
            res = res * a;
        a = a * a, k &gt;&gt;= 1;
    &#125;
&#125;
</code></pre>
<h2 id="最大公约数-欧几里得算法（GCD）"><a href="#最大公约数-欧几里得算法（GCD）" class="headerlink" title="最大公约数-欧几里得算法（GCD）"></a>最大公约数-欧几里得算法（GCD）</h2><p>$$<br>当a&gt;b,则\gcd(a,b)&#x3D;\gcd(b,a\bmod b)<br>$$</p>
<pre><code class="c++">int gcd(int a, int b)
&#123;
    if (a &lt; b) // 确保a大
        swap(a, b);
    if (b == 0)
        return a;
    else
        return gcd(b, a % b);
&#125;
</code></pre>
<h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><h3 id="判断素数-试除法"><a href="#判断素数-试除法" class="headerlink" title="判断素数-试除法"></a>判断素数-试除法</h3><pre><code class="C++">bool prime(int x)
&#123;
    if (x == 1)
        return 0;
    for (int i = 2; i &lt;= x / i; i++)
    &#123;
        if (x % i == 0)
            return 0;
    &#125;
    return 1;
&#125;
</code></pre>
<h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h3><p>$$<br>n&#x3D;p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\dots p_s^{\alpha_s},p_1&lt;p_2&lt;p<br>_3&lt;\dots&lt;p_S<br>$$</p>
<pre><code class="C++">const int N = 500005;
int a[N]; // 代表含质因子i的个数
void decompose(int x)
&#123;
    for (int i = 2; i &lt;= x / i; i++)
    &#123;
        while (x % i == 0)
            a[i]++, x /= i;
    &#125;
    if (x &gt; 1)
        a[x]++;
&#125;
</code></pre>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><h3 id="埃氏筛法"><a href="#埃氏筛法" class="headerlink" title="埃氏筛法"></a>埃氏筛法</h3><pre><code class="C++">const int N = 100000010; // 最大
int vis[N] = &#123;0&#125;;        // 划掉合数
int prim[N] = &#123;0&#125;;       // 记录质数
int cnt;                 // 质数个数
void Eratosthenes(int n) // 埃氏筛法
&#123;
    for (long long i = 2; i &lt;= n; ++i)
        if (!vis[i])
        &#123;
            prim[++cnt] = i;
            for (long long j = i * i; j &lt;= n; j += i)
                vis[j] = 1;
        &#125;
&#125;
</code></pre>
<h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><pre><code class="c++">//注意空间，prim有效从下标1开始
const int N = 100000010; // 最大
int vis[N] = &#123;0&#125;;        // 划掉合数
int prim[N] = &#123;0&#125;;       // 记录质数
int cnt = 0;             // 质数个数
void get_prim(int n)
&#123;
    for (int i = 2; i &lt;= n; i++)
    &#123;
        if (vis[i] == 0)
            prim[++cnt] = i;
        for (int j = 1; 1ll * i * prim[j] &lt;= n; j++)
        &#123;
            vis[i * prim[j]] = 1;
            if (i % prim[j] == 0)
                break;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>**欧拉函数 **$\varphi(n)$ 指小于 $n$ ，并且与 $n$ 互质的数的个数。</p>
<p> $\varphi ( n ) &#x3D; \sum\limits _ { i &#x3D; 1 } ^ { n } [ \gcd ( i , n ) &#x3D; 1 ]$ </p>
<p>性质： $\sum\limits _ { d | n } \varphi ( d ) &#x3D; n$ </p>
<ul>
<li>当 $n$ 为质数，$\varphi (n)&#x3D;p-1$ </li>
<li>当 $p$ 为质数，$\varphi (p^k)&#x3D;(p-1)*p^{k-1}$ </li>
<li>当 $n$ 为合数，$\varphi (n)&#x3D;s*\prod \limits_{i&#x3D;1}^s{\frac{p_i-1}{pi}}$ <ul>
<li>$n&#x3D;p_1^{\alpha_1}p_2^{\alpha_2}p_3^{\alpha_3}\dots p_s^{\alpha_s},p_1&lt;p_2&lt;p<br>_3&lt;\dots&lt;p_S$</li>
</ul>
</li>
</ul>
<p>求单个欧拉函数，代码使用<strong>试除法</strong>，多个使用<strong>线性筛</strong>。</p>
<pre><code class="C++">// 求单个欧拉函数，试除法
int get_phi(int n) 
&#123;
    int res = n;
    for (int i = 2; i * i &lt;= n; i++)
    &#123;
        if (n % i == 0)
        &#123;
            res = res / i * (i - 1);
            while (n % i == 0)
                n /= i;
        &#125;
    &#125;
    if (n &gt; 1)
        res = res / n * (n - 1);
    return res;
&#125;
</code></pre>
<h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p><strong>约数个数定理</strong>：若 $n&#x3D;\prod \limits_{i&#x3D;1}^s{p_i^{\alpha_i}}$ ，约数个数 $d(n)&#x3D;\prod \limits_{i&#x3D;1}^s{(\alpha_i+1)}$ </p>
<p><strong>约数和定理</strong>：若 $n&#x3D;\prod \limits_{i&#x3D;1}^s{p_i^{\alpha_i}}$ ，约数和 $f(n)&#x3D;\prod \limits_{i&#x3D;1}^s{\sum_{j&#x3D;0}^{\alpha_{i}}{p_i^j}}$ </p>
<h3 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h3><p><strong>莫比乌斯函数</strong>：$\begin{align*}\begin{split}\mu(n)&#x3D; \left {\begin{array}{lr}1,&amp; n&#x3D;1\0,&amp; n含相同质因子\(-1)^s,&amp; s为n的不同质因子的个数\end{array}\right.\end{split}\end{align*}$ </p>
<p>性质： $\sum\limits _ { d | n } \mu( d ) &#x3D; [ n &#x3D; 1 ]$  </p>
<h2 id="同余式"><a href="#同余式" class="headerlink" title="同余式"></a>同余式</h2><p>若 $a,b$ 模 $m$ 余数相同，则 $a,b$ 模 $m$ 同余。</p>
<p>即 $ a\equiv b(\bmod m)$ </p>
<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p> 若 $p$ 为质数，且 $a,p$ 互质，则 $a^{p-1}\equiv (\bmod p)$ </p>
<h3 id="乘法逆元（费马小定理）"><a href="#乘法逆元（费马小定理）" class="headerlink" title="乘法逆元（费马小定理）"></a>乘法逆元（费马小定理）</h3><p>若 $a,p$ 互质，且满足同余方程 $ax\equiv 1(\bmod p)$，则 $x$ 为 $a$ 模 $p$ 的乘法逆元，记作 $a^{-1}$；</p>
<p><strong>若 $p$ 为质数</strong>，根据<strong>费马小定理</strong>可知 $a^{p-2}\times a \equiv (\bmod p)$， $x&#x3D;a^{p-2}(\bmod p)$； </p>
<p>代码使用<strong>快速幂取模</strong>求$a^{p-2}(\bmod p)$。</p>
<h3 id="剩余系"><a href="#剩余系" class="headerlink" title="剩余系"></a>剩余系</h3><p><strong>剩余系（同余系）</strong>：给定一个正整数 $n$ ，把所有整数<strong>根据模 $n$ 的余数</strong> $r∈[0,n -1]$ 分为 $n$ 类，每一类表示为 $C_r &#x3D; nx +r$ 的形式，这类数所构成的一个集合称为模 $n$ 的剩余类。</p>
<p><strong>完全剩余系（完系）</strong>：给定一个正整数 $n$ ，有 $n$ 个不同的模 $n$ 的剩余类，从这 $n$ 个不同的剩余类中<strong>各取出一个元素</strong>，总共 $n$ 个数,将这些数构成一个新的集合，则称这个集合为模 $n$ 的完全剩余系。</p>
<p><strong>简化剩余系（缩系）</strong>：给定一个正整数 $n$ ，有 $\varphi (n)$ 个不同的模 $n$ 的<strong>余数 $r$ 与 $n$ 互质</strong>的剩余类，从这 $\varphi(n)$ 个剩余类中各取出一个元素，总共 $\varphi(n)$ 个数,将这些数构成一个新的集合，则称这个集合为模 $n$ 的简化剩余系。</p>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>若 $\gcd(a,m)&#x3D;1$，则 $a^{\varphi(m)}\equiv 1(\bmod m)$；</p>
<p>当 $m$ 为质数时，由于 $\varphi (m)&#x3D;m-1$ ，带入欧拉定理可得<strong>费马小定理</strong> $a^{m-1}\equiv m$ ；</p>
<h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><ul>
<li>当 $b$ 小时，直接快速幂；</li>
<li>当 $b$ 大时，先降，再快速幂；</li>
</ul>
<p> $a^b&#x3D;\begin{align*}\begin{split} \left {\begin{array}{lr}a^b,&amp; b&lt;\varphi(m)\a^{b \ \bmod \ \varphi(m)+\varphi(m)},&amp; b\ge\varphi(m)\end{array}\right.\end{split}\end{align*} ,(\bmod m)$ </p>
<p>代码：<strong>欧拉函数</strong>+<strong>高精度取模</strong>+<strong>快速幂取模</strong></p>
<pre><code class="C++">typedef long long ll;
int get_phi(int n) // 求单个欧拉函数
&#123;
    int res = n;
    for (int i = 2; i * i &lt;= n; i++)
    &#123;
        if (n % i == 0)
        &#123;
            res = res / i * (i - 1);
            while (n % i == 0)
                n /= i;
        &#125;
    &#125;
    if (n &gt; 1)
        res = res / n * (n - 1);
    return res;
&#125;
int depow(int phi, string bs) // 高精度取模降幂
&#123;
    int b = 0, flag = 0; // b为返回值，flag为标记是否需要最后+phi(x)
    for (int i = 0; bs[i]; i++)
    &#123;
        b = b * 10 + bs[i] - &#39;0&#39;;
        if (b &gt;= phi)
            flag = 1, b %= phi;
    &#125;
    if (flag)
        b += phi;
    return b;
&#125;
int qpow(ll a, int b, int p) // 快速幂取模
&#123;
    int res = 1;
    while (b)
    &#123;
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    &#125;
    return res;
&#125;
int Euler(int a, string bs, int p) // 欧拉定理,求a^b % p
&#123;
    int phi = get_phi(p);   // 先求phi(p)
    int b = depow(phi, bs); // 高精度取模降幂
    return qpow(a, b, p);   // 快速幂取模
&#125;
</code></pre>
<h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>$(p-1)!\equiv -1(\bmod p) \Longleftrightarrow p$ 为质数</p>
<ul>
<li>推论<ol>
<li>若 $p$ 是质数，则 $(p-1) !+1 \equiv 0(\bmod p)$</li>
<li>若 $p$ 是大于 $4$ 的合数，则 $(p-1) ! \equiv 0(\bmod p)$</li>
<li>$p&#x3D;1$，$(1-1)! \equiv 0(\bmod1)$；</li>
<li>$p&#x3D;4$，$(4-1)! \equiv 2(\bmod 4)$；</li>
</ol>
</li>
</ul>
<h3 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h3><p><strong>裴蜀定理</strong>：一定存在整数 $x,y$ ，满足 $ax+by&#x3D;gcd(a,b)$ ；</p>
<p><strong>推广</strong>：$\sum <em>{i&#x3D;1}^{n}A</em>{i}X_{i}&#x3D;gcd(A_{1},A_{2}, \cdots ,A_{n})$</p>
<h3 id="扩展欧几里得定理"><a href="#扩展欧几里得定理" class="headerlink" title="扩展欧几里得定理"></a>扩展欧几里得定理</h3><p>$Q$ ：求 $ax+by&#x3D;gcd(a,b)$ 一组整数解</p>
<p>当 $b&#x3D;0$ 时，$ax+by&#x3D;a$，则 $x&#x3D;1$，$y&#x3D;0$</p>
<p>当 $b\neq 0$时，由<strong>裴蜀定理</strong></p>
<p>​					 $gcd(a,b)&#x3D;ax+by$ </p>
<p>​					$gcd(b,a%b)&#x3D;bx_1+(a%b)y_1&#x3D;ay_1+b(x_1-\lfloor\frac{a}{b}\rfloor y_1)$</p>
<p>​					<strong>递推公式</strong>：$x_n&#x3D;y_{n-1},y_n&#x3D;x_{n-1}-\lfloor\frac{a}{b}\rfloor y_{n-1}$ </p>
<p>​					求得**特解 $x_0,y_0$**；</p>
<p>​					<strong>通解</strong>：$\begin{align*}\begin{split} \left {\begin{array}{lr}x&#x3D;x_0+\frac{b}{gcd(a,b)}*k\y&#x3D;y_0-\frac{a}{gcd(a,b)}<em>k\end{array}\right.\end{split}\end{align</em>} (考虑ax+by&#x3D;0构造)$</p>
<p>求<strong>最靠近原点</strong>的一组<strong>特解</strong> $x_2,y_2$ </p>
<p>则需满足条件 $x_2+y2$ </p>
<p><em>求特解代码</em></p>
<pre><code class="C++">int exgcd(int a, int b, int &amp;x, int &amp;y) // a&gt;=b 注意数值范围
&#123;
    if (b == 0)
    &#123;
        x = 1, y = 0;
        return a; // 最大公约数
    &#125;
    int x1, y1, d;
    d = exgcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - a / b * y1;
    return d; // 最大公约数
&#125;
</code></pre>
<h3 id="不定方程"><a href="#不定方程" class="headerlink" title="不定方程"></a>不定方程</h3><p>$Q$ ：求 $ax+by&#x3D;c$ 一组整数解</p>
<p>若 $gcd(a,b)\nmid c$ ，则无整数解；</p>
<p>若 $gcd(a,b)\mid c$，则先求 $ax+by&#x3D;gcd(a,b)$ 整数解，然后乘以相应倍数 $\frac{c}{gcd(a,b)}$；</p>
<p>转化为<strong>扩展欧几里得定理</strong> </p>
<h3 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h3><p> $ax \equiv b(\bmod m)$ </p>
<p> $ax&#x3D;m(-y)+b$ </p>
<p>  $ax+my&#x3D;b$ </p>
<p>转化为<strong>不定方程</strong> </p>
<h3 id="乘法逆元（通用）"><a href="#乘法逆元（通用）" class="headerlink" title="乘法逆元（通用）"></a>乘法逆元（通用）</h3><p> 若 $a,m$ 互质，求 $ax \equiv 1(\bmod m)$ 的解 $x$ ；</p>
<p>转化为<strong>不定方程</strong>即 $ax+my&#x3D;1$ </p>
<p>使用<strong>扩展欧几里得算法</strong>的到 $ax+my&#x3D;gcd(a,m)$ 解 $x$ ；</p>
<p>最终答案：$(x % m+m)% m$ ，“模加模”保证得到<strong>最小正整数</strong>；</p>
<h3 id="中国剩余定理（CRT）"><a href="#中国剩余定理（CRT）" class="headerlink" title="中国剩余定理（CRT）"></a>中国剩余定理（CRT）</h3><p>求解线性同余方程</p>
<p>$\left{ \begin{matrix} x \equiv r_{1}(\bmod m_{1})\ x \equiv r_{2}(\bmod m_{2})\ \vdots\ x \equiv r_{n}(\bmod m_{n})\ \end{matrix} \right.$</p>
<p>其中模数 $m_1, m_2,… , m_n$为 <strong>两两互质</strong>的整数,求 $x$ 的最小非负整数解。</p>
<ol>
<li>计算所有模数的积 $M$ </li>
<li>计算第 $i$ 个方程的 $c_{i}&#x3D;\frac{M}{m_{i}}$ </li>
<li>计算 $c_{i}$ 在模 ${m}<em>{i}$ 意义下的逆元 $c</em>{i}^{-1}$ </li>
<li>$x&#x3D;\sum_{i&#x3D;1}^{n} r_{i} c_{i} c_{i}^{-1}(\bmod M)$</li>
</ol>
<pre><code class="C++">typedef long long ll;
ll n; // 式子总数
ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y) // 扩展欧几里得算法
&#123;
    if (b == 0)
    &#123;
        x = 1, y = 0;
        return a;
    &#125;
    ll d, x1, y1;
    d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
&#125;

ll CRT(ll m[], ll r[]) // 中国剩余定理 x=r(mod m) 从0开始
&#123;
    ll M = 1, ans = 0;
    ll x, y;
    for (int i = 0; i &lt; n; i++)
        M *= m[i];
    for (int i = 0; i &lt; n; i++)
    &#123;
        ll c = M / m[i];
        exgcd(c, m[i], x, y);
        ans = (ans + r[i] * c * x % M) % M;
    &#125;
    return (ans % M + M) % M; // 最小非负整数解
&#125;
</code></pre>
<h3 id="扩展中国剩余定理（EXCRT）"><a href="#扩展中国剩余定理（EXCRT）" class="headerlink" title="扩展中国剩余定理（EXCRT）"></a>扩展中国剩余定理（EXCRT）</h3><p>求解线性同余方程</p>
<p>$\left{ \begin{matrix} x \equiv r_{1}(\bmod m_{1})\ x \equiv r_{2}(\bmod m_{2})\ \vdots\ x \equiv r_{n}(\bmod m_{n})\ \end{matrix} \right.$  </p>
<p>其中模数 $m_1, m_2,… , m_n$ <strong>不一定</strong> 为 <strong>两两互质</strong>的整数,求 $x$ 的最小非负整数解。</p>
<p>前两个方程： $x \equiv r_{1}\left(\bmod m_{1}\right), x \equiv r_{2}\left(\bmod m_{2}\right)$ </p>
<p>转化为<strong>不定方程</strong>： $x &#x3D; m_{1} p+r_{1} &#x3D; m_{2} q+r_{2}$ </p>
<p>则 $m_{1} p-m_{2} q &#x3D; r_{2}-r_{1}$ </p>
<p>由<strong>裴蜀定理</strong>，当 $\operatorname{gcd}\left(m_{1}, m_{2}\right) \nmid\left(r_{2}-r_{1}\right)$ 时，无解</p>
<p>​					   当 $\operatorname{gcd}\left(m_{1}, m_{2}\right) \mid\left(r_{2}-r_{1}\right)$ 时，有解</p>
<p>由<strong>扩欧算法</strong>，得特解 $p &#x3D; p * \frac{r_{2}-r_{1}}{g c d}, q &#x3D; q * \frac{r_{2}-r_{1}}{g c d}$ </p>
<p>其<strong>通解</strong>  $P &#x3D; p+\frac{m_{2}}{g c d} * k, Q &#x3D; q-\frac{m_{1}}{g c d} * k$ </p>
<p>所以  $x &#x3D; m_{1} P+r_{1} &#x3D; \frac{m_{1} m_{2}}{g c d} * k+m_{1} p+r_{1}$ </p>
<p>前两个方程等价合并为一个方程 $x \equiv r(\bmod m)$ </p>
<p>其中<strong style="background:rgb(225,255,255);"> $r&#x3D;m_1p+r_1，m&#x3D;lcm⁡(m_1,m_2) $</strong></p>
<p>所以 $n$ 个同余方程只要合并 $n-1$ 次, 即可求解</p>
<pre><code class="C++">typedef long long ll;
ll n; // 式子总数
ll EXCRT(ll m[], ll r[]) // 扩展中国剩余定理 x=r(mod m) 从0开始
&#123;
    ll m1, m2, r1, r2, p, q, d;
    m1 = m[0];
    r1 = r[0];
    for (int i = 1; i &lt; n; i++)
    &#123;
        m2 = m[i];
        r2 = r[i];
        d = exgcd(m1, m2, p, q);
        if ((r2 - r1) % d) // 无解
            return -1;
        p = p * (r2 - r1) / d;                  // 特解
        p = (p % (m2 / d) + m2 / d) % (m2 / d); // 保证正数
        r1 = m1 * p + r1;
        m1 = m1 * m2 / d;
    &#125;
    return (r1 % m1 + m1) % m1;
&#125;
</code></pre>
<h3 id="BSGS算法"><a href="#BSGS算法" class="headerlink" title="BSGS算法"></a>BSGS算法</h3><p>给定整数 $a,b,p$，其中 $a,p$ 互质，</p>
<p>求满足 $a^x \equiv  b(\bmod p)$ 最小非负整数 $x$ </p>
<h3 id="扩展BSGS算法"><a href="#扩展BSGS算法" class="headerlink" title="扩展BSGS算法"></a>扩展BSGS算法</h3><h2 id="线性方程"><a href="#线性方程" class="headerlink" title="线性方程"></a>线性方程</h2><h3 id="高斯消元法"><a href="#高斯消元法" class="headerlink" title="高斯消元法"></a>高斯消元法</h3><p><strong>矩阵的初等行变换</strong></p>
<ol>
<li>交<strong>换</strong>两行；</li>
<li>把某一行乘一个**非 $0$ **的数；</li>
<li>把某行的若干倍<strong>加</strong>到另一行上去；</li>
</ol>
<p>先把系数矩阵消成<strong>上三角矩阵</strong>，再从下到上<strong>回代</strong>求解</p>
<p>$\left[\begin{array}{ccccccc}<br>1 &amp; \mathrm{a}<em>{12}^{\prime} &amp; a</em>{13}^{\prime} &amp; a_{14}^{\prime} &amp; \cdots &amp; a_{1 n}^{\prime} &amp; b_{1}^{\prime} \<br>&amp; 1 &amp; a_{23}^{\prime} &amp; a_{24}^{\prime} &amp; \cdots &amp; a_{2 n}^{\prime} &amp; b_{2}^{\prime} \<br>&amp; &amp; 1 &amp; a_{34}^{\prime} &amp; \cdots &amp; a_{3 n}^{\prime} &amp; b_{3}^{\prime} \<br>&amp; &amp; &amp; \ddots &amp;\ddots &amp; \vdots &amp; \vdots \<br>&amp; &amp; &amp; &amp;1 &amp; a_{n-1, n}^{\prime} &amp; b_{n-1}^{\prime} \<br>&amp; &amp; &amp; &amp; &amp; 1 &amp; \mathrm{~b}_{n}^{\prime}<br>\end{array}\right]$</p>
<ol>
<li>枚举<strong>主元</strong>, 找到主元下面系数不是 $0$ 的一行；</li>
<li>用<strong>变换1</strong>, 把这一行与主元行交换；</li>
<li>用<strong>变换2</strong>, 把主元系数变成 $1$ ；</li>
<li>用<strong>变换3</strong>, 把主元下面的系数变成 $0$ 。</li>
</ol>
<h2 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h2><h3 id="递推法（杨辉三角）"><a href="#递推法（杨辉三角）" class="headerlink" title="递推法（杨辉三角）"></a>递推法（杨辉三角）</h3><p><em><strong>时间复杂度： $O(n^2)$</strong></em> </p>
<ul>
<li><p>$C _ { n } ^ { 0 } &#x3D; C _ { n } ^ { n } &#x3D; 1$ </p>
</li>
<li><p>$C _ { n } ^ { m } &#x3D; C _ { n } ^ { n - m }$ </p>
</li>
<li><p><strong style="color:red;">$C _ { n } ^ { m } &#x3D; C _ { n - 1 } ^ { m } + C _ { n - 1 } ^ { m - 1 }$ </strong></p>
</li>
</ul>
<img src="C:/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/image-20230729155557911.png" alt="image-20230729155557911" style="zoom:50%;" />

<pre><code class="C++">// 调用C[n][m]即可
const int N = 2010;
const int MOD = 1e9 + 7;
int C[N][N];
void init() // 组合数模MOD
&#123;
    for (int i = 0; i &lt; N; i++)
        C[i][0] = 1; // 第一列全为1
    for (int i = 1; i &lt; N; i++)
        for (int j = 1; j &lt;= i; j++)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
&#125;
</code></pre>
<h3 id="快速幂求组合数"><a href="#快速幂求组合数" class="headerlink" title="快速幂求组合数"></a>快速幂求组合数</h3><p><em><strong>时间复杂度： $O(n\log p)$</strong></em> </p>
<ul>
<li>$C _ { n } ^ { m } &#x3D; \frac { n ! } { ( n - m ) ! m ! }$</li>
</ul>
<p>开两个数组分别存模意义下的<strong>阶乘</strong>和<strong>阶乘的逆元</strong></p>
<p>用 $f[x]$ 存 $x!(\bmod p)$ 的值</p>
<p>用 $g[x]$ 存 $(x!)^{-1}(\bmod p)$ 的值，使用<strong>费马小定理</strong>和<strong>快速幂</strong>求逆元</p>
<p>费马小定理： $a \cdot ( a ^ { p - 2 } ) &#x3D; 1 ( \bmod p )$ </p>
<p> $g[x]$ 递推公式： $\frac { 1 } { i! } ( \bmod p ) &#x3D; \frac { 1 } { i } \times \frac { 1 } { ( i - 1 ) ! } ( \bmod p ) &#x3D; i^{p-2} * g [ i - 1 ] (\bmod p)$ </p>
<p>查询时使用： $C _ { n } ^ { m } ( \bmod p ) &#x3D; f [ n ] * g [ n - m ] * g [ m ] ( \bmod p )$ </p>
<pre><code class="C++">typedef long long ll;
const int N = 100010;
const int MOD = 1e9 + 7;
ll f[N];             // f存 i!%MOD的值
ll g[N];             // g存 i!%MOD的逆元 值
ll qpow(ll a, int b) // 快速幂取模
&#123;
    ll res = 1;
    while (b)
    &#123;
        if (b &amp; 1)
            res = res * a % MOD;
        a = a * a % MOD;
        b &gt;&gt;= 1;
    &#125;
    return res;
&#125;
void init() // 初始化
&#123;
    f[0] = g[0] = 1; // 0！逆元和自己都是1
    for (int i = 1; i &lt; N; i++)
    &#123;
        f[i] = f[i - 1] * i % MOD;
        g[i] = g[i - 1] * qpow(i, MOD - 2) % MOD; // 递推 （之前的逆元）乘以（1/i的逆元）
    &#125;
&#125;
ll getC(ll n, ll m) // 获得C(n,m)
&#123;
    return f[n] * g[m] % MOD * g[n - m] % MOD;
&#125;
</code></pre>
<h3 id="卢卡斯定理（Lucas）"><a href="#卢卡斯定理（Lucas）" class="headerlink" title="卢卡斯定理（Lucas）"></a>卢卡斯定理（Lucas）</h3><p><em><strong>时间复杂度： $O(p\log p + \log_p n)$</strong></em> </p>
<p>$C _ { n } ^ { m } &#x3D; C _ { n &#x2F; p } ^ { m&#x2F;p } C _{n\bmod p} ^{m \bmod p} ( \bmod p )$ ，其中 $p$ 为质数</p>
<p>$n\bmod p$和 $n\bmod p$ 一定是小于 $p$ 的数，可以直接求解， $ C _ { n &#x2F; p } ^ { m&#x2F;p }$ 可以继续用 <strong>Lucas定理</strong> 求解。</p>
<p>边界条件：当 $m&#x3D;0$ 时，返回 $1$ 。</p>
<p>证明：</p>
<ul>
<li><strong>引理1</strong>： $C _ { p } ^ { x } &#x3D; 0 ( \bmod p ) , 0 \lt x \lt p$ <ul>
<li>$C _ { p } ^ { x } &#x3D; \frac { p ! } { x ! ( p - x ) ! } &#x3D; \frac { p ( p - 1 ) ! } { x ( x - 1 ) ! ( p - x ) ! } &#x3D; \frac { p } { x } C _ { p - 1 } ^ { x - 1 }$</li>
<li>$C _ { p } ^ { x } &#x3D; p \cdot i n v ( x )  {  C _ { p - 1 } ^ { x - 1 } } &#x3D; 0 ( \bmod p )$</li>
</ul>
</li>
<li><strong>引理2</strong>： $( 1 + x ) ^ { p } &#x3D; 1 + x ^ { p } ( \bmod p )$<ul>
<li>二项式定理知： $( 1 + x ) ^ { p } &#x3D; \sum _ { i &#x3D; 0 } ^ { p } C _ { p } ^ { i } x ^ { i }$ </li>
<li>由上一证明知，只剩 $i&#x3D;0,p$ 两项，得证。</li>
</ul>
</li>
<li>证明：</li>
</ul>
<p> $( 1 + x ) ^ { n } \equiv \sum _ { i &#x3D; 0 } ^ { n } C _ { n } ^ { i } x ^ { i } ( m o d p ) – ( 1 )$ </p>
<p> $\begin{aligned}<br>(1+x)^{n} &amp; \equiv(1+x)^{a p+b} \<br>&amp; \equiv\left((1+x)^{p}\right)^{a} \cdot(1+x)^{b} \<br>&amp; \equiv\left(1+x^{p}\right)^{a} \cdot(1+x)^{b} \<br>&amp; \equiv \sum_{i&#x3D;0}^{a} C_{a}^{i} x^{i p} \cdot \sum_{j&#x3D;0}^{b} C_{b}^{j} x^{j}(\bmod p)–(2)<br>\end{aligned}$ </p>
<p> $(1)$ 中 $x ^ { m }$ 的系数为 $C_{n}^{m}$ </p>
<p> $(2)$ 中 $x^m &#x3D;x^{cp} \cdot x^d$ 的系数为 $C _ { a } ^ { c } C _ { b } ^ { d }$ </p>
<p>则： $C _ { n } ^ { m } &#x3D; C _ { a } ^ { c } C _ { b } ^ { d } ( \bmod p )$ </p>
<p>即： $C _ { n } ^ { m } &#x3D; C _ { n &#x2F; p } ^ { m&#x2F;p } C _{n\bmod p} ^{m \bmod p} ( \bmod p )$ </p>
<pre><code class="C++">typedef long long ll;
const int N = 100010;
ll f[N], g[N];
// 快速幂
ll qpow(ll a, int b, int p)
&#123;
    ll res = 1;
    while (b)
    &#123;
        if (b &amp; 1)
            res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    &#125;
    return res;
&#125;
// 预处理
void init(int p)
&#123;
    f[0] = g[0] = 1;
    for (int i = 1; i &lt;= p; i++)
    &#123;
        f[i] = f[i - 1] * i % p;
        g[i] = g[i - 1] * qpow(i, p - 2, p) % p;
    &#125;
&#125;
// 小数组合数
ll getC(int n, int m, int p)
&#123;
    return f[n] * g[m] * g[n - m] % p;
&#125;
// 卢卡斯定理 Lucas
int lucas(ll n, ll m, int p)
&#123;
    if (m == 0)
        return 1;
    return lucas(n / p, m / p, p) * getC(n % p, m % p, p) % p;
&#125;
</code></pre>
<h3 id="线性筛-高精度求组合数（单个）"><a href="#线性筛-高精度求组合数（单个）" class="headerlink" title="线性筛+高精度求组合数（单个）"></a>线性筛+高精度求组合数（单个）</h3><p><em><strong>时间复杂度： $O(mnN)$</strong></em>  $N$ 为数字位数</p>
<p> $n!$ 中 $p$ 的个数 $s &#x3D; \frac { n } { p } + \frac { n } { p ^ { 2 } } + \frac { n } { p ^ { 3 } } + \cdots$</p>
<pre><code class="C++">// N为组合数n的最大大小
const int N = 10010;
int prim[N], vis[N], cnt; // prim[]存储素数，vis[]存储访问情况，cnt代表素数个数
// 线性筛 筛素数
void get_prim(int n)
&#123;
    for (int i = 2; i &lt;= n; i++)
    &#123;
        if (!vis[i])
            prim[cnt++] = i;
        for (int j = 0; i * prim[j] &lt;= n; j++)
        &#123;
            vis[i * prim[j]] = 1;
            if (i % prim[j] == 0)
                break;
        &#125;
    &#125;
&#125;
// n!中p的个数
int get(int n, int p)
&#123;
    int s = 0;
    while (n)
        s += n / p, n /= p;
    return s;
&#125;
// C中p的个数
int getps(int n, int m, int p)
&#123;
    return get(n, p) - get(m, p) - get(n - m, p);
&#125;
// 高精度乘法
void mul(int C[], int p, int &amp;len)
&#123;
    int t = 0;
    for (int i = 0; i &lt; len; i++)
    &#123;
        t += C[i] * p;
        C[i] = t % 10;
        t /= 10;
    &#125;
    while (t)
    &#123;
        C[len++] = t % 10;
        t /= 10;
    &#125;
&#125;
// Cnm的结果存储在C[]中，返回C的长度
int getC(int n, int m, int C[])
&#123;
    /////////////////////////////
    // 全局只需要进行一次最大的即可
    get_prim(n);
    // 全局只需要进行一次最大的即可
    ////////////////////////////
    // 外部定义
    // int C[N];
    ////////////////////////////
    int len = 1;
    C[0] = 1;
    for (int i = 0; i &lt; cnt; i++)
    &#123;
        int p = prim[i];
        int s = getps(n, m, p);
        while (s--)
            mul(C, p, len);
    &#125;
    // 打印
    //  for (int i = len - 1; i &gt;= 0; i--)
    //      cout&lt;&lt; C[i];
    // 最后结果存储在C[]中
    return len; // 返回C的长度
&#125;
</code></pre>
<h3 id="递推法-高精度（单个）"><a href="#递推法-高精度（单个）" class="headerlink" title="递推法+高精度（单个）"></a>递推法+高精度（单个）</h3><p>时间不推荐，推荐 前面那个 <strong>线性筛+高精度求组合数（单个）</strong></p>
<p><em><strong>时间复杂度： $O(mnN)$</strong></em>  $N$ 为数字位数</p>
<pre><code class="C++">// 组合数的最大数位
const int N = 500;
// 第一位表示最大的n，第二位表示最大的m，第三位表示数位（注意倒叙）
int C[500][100][N];
// 高精度加法
void add(int c[], int a[], int b[])
&#123;
    for (int i = 0; i &lt; N; i++)
    &#123;
        c[i] += a[i] + b[i];
        c[i + 1] += c[i] / 10;
        c[i] %= 10;
    &#125;
&#125;
// 求组合数
void getC(int n, int m)
&#123;
    for (int i = 0; i &lt;= n; i++)
        for (int j = 0; j &lt;= i &amp;&amp; j &lt;= m; j++)
            if (j == 0)
                C[i][j][0] = 1;
            else
                add(C[i][j], C[i - 1][j], C[i - 1][j - 1]);
&#125;
// 输出 使用方法
void print(int n, int m)
&#123;
    int i = N - 1;
    // 删除前导0
    while (C[n][m][i] == 0)
        i--;
    while (i &gt;= 0)
        printf(&quot;%d&quot;, C[n][m][i--]);
&#125;
</code></pre>
<h3 id="组合数命名空间（快速幂）"><a href="#组合数命名空间（快速幂）" class="headerlink" title="组合数命名空间（快速幂）"></a>组合数命名空间（快速幂）</h3><pre><code class="C++">typedef long long i64;
const i64 mod = 998244353;
i64 fpow(i64 x, i64 r)
&#123;
    i64 result = 1;
    while (r)
    &#123;
        if (r &amp; 1)
            result = result * x % mod;
        r &gt;&gt;= 1;
        x = x * x % mod;
    &#125;
    return result;
&#125;

namespace binom
&#123;
    i64 fac[N], ifac[N];
    int __ = []
    &#123;
        fac[0] = 1;
        for (int i = 1; i &lt;= N - 5; i++)
            fac[i] = fac[i - 1] * i % mod;
        ifac[N - 5] = fpow(fac[N - 5], mod - 2);
        for (int i = N - 5; i; i--)
            ifac[i - 1] = ifac[i] * i % mod;
        return 0;
    &#125;();

    inline i64 C(int n, int m)
    &#123;
        if (n &lt; m || m &lt; 0)
            return 0;
        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;
    &#125;

    inline i64 A(int n, int m)
    &#123;
        if (n &lt; m || m &lt; 0)
            return 0;
        return fac[n] * ifac[n - m] % mod;
    &#125;
&#125;
using namespace binom;
</code></pre>
<h3 id="隔板法"><a href="#隔板法" class="headerlink" title="隔板法"></a>隔板法</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1771">洛谷 P1771 方程的解</a></p>
<ol>
<li>求线性不定方程的整数解的组数</li>
<li>求相同元素分组的方案数</li>
</ol>
<ul>
<li><strong>现有 $n$ 个完全相同的元素，将其分为 $k$ 组，保证每组至少有 $1$ 个元素，一共有多少种分法？</strong></li>
</ul>
<p>​	把 $n$ 个相同的球排成一行，有 $n-1$ 个空；</p>
<p>​	拿 $k-1$ 块板子插入到 $n-1$ 个空里，把球分成 $k$ 组；</p>
<p>​	即在 $n-1$ 个空里选择 $k-1$ 个空插板子，所以答案就是<strong style="color:red;"> $C_{n-1}^{k-1}$ </strong>；</p>
<p><strong>？1</strong> <strong>正整数和的组数</strong> 若 $x _ { i } \geq 1$ ，求 $x _ { 1 } + x _ { 2 } + \cdots + x _ { k } &#x3D; n$ 的整数解的组数。 <strong style="color:red;"> $C_{n-1}^{k-1}$ </strong></p>
<p><strong>？2</strong> <strong>非负整数和的组数</strong> 若 $x _ { i } \geq 0$ ，求 $x _ { 1 } + x _ { 2 } + \cdots + x _ { k } &#x3D; n$ 的整数解的组数。 <strong style="color:red;">$C _ { n + k - 1 } ^ { k - 1 }$</strong></p>
<p>​		令 $y_i&#x3D;x_i+1$ ，则 $y _ { i } \geq 1$ ；</p>
<p>​		则 转化为 $y _ { 1 } + y _ { 2 } + \cdots + y _ { k } &#x3D; n + k &#x3D; m$ </p>
<p>​		转化为 <strong>？1</strong> ，答案为 $C _ { m - 1 } ^ { k - 1 } &#x3D; C _ { n + k - 1 } ^ { k - 1 }$ </p>
<p><strong>？3</strong> <strong>不同下界整数和的组数</strong> 求 $x _ { 1 } + x _ { 2 } + \cdots + x _ { k } &#x3D; n$ 的整数解的组数，其中 $x _ { i } \geq a _ { i } \geq 0 $ ，$\sum a _ { i } \leq n$  <strong style="color:red;">$C _ { n - \sum a _ { i } + k -1} ^ { k - 1 }$</strong></p>
<p>​		令 $y _ { i } &#x3D; x _ { i } - a _ { i } + 1$ ，则 $y _ { i } \geq 1$ ；</p>
<p>​		则 转化为 $y _ { 1 } + y _ { 2 } + \cdots + y _ { k } &#x3D; n - \sum a _ { i } + k &#x3D; m$</p>
<p>​		转化为 <strong>？1</strong> ，答案为 $C _ { m - 1 } ^ { k - 1 } &#x3D; C _ { n - \sum a _ { i } + k -1} ^ { k - 1 } $ </p>
<h3 id="卡特兰数（Catalan）"><a href="#卡特兰数（Catalan）" class="headerlink" title="卡特兰数（Catalan）"></a>卡特兰数（Catalan）</h3><p>两种操作，一种操作数不能超过另外一种操作数，或者两种操作不能有交集，这些操作的合法方案数，通常是卡特兰数。</p>
<p>以走网格为例，从格点 $(0,0)$ 走到格点 $(n,n)$ ，只能向右或向上走，并且不能越过对角线的路径的条数，就是卡特兰数，记为 $H_n$ 。</p>
<ul>
<li>组合数： $H _ { n } &#x3D; C _ { 2 n } ^ { n } - C _ { 2 n } ^ { n - 1 }$ </li>
<li>组合数： $H _ { n } &#x3D; \frac { 1 } { n + 1 } C _ { 2 n } ^ { n }$ </li>
<li>递推计算： $H _ { n } &#x3D; \frac { 4 n - 2 } { n + 1 } H _ { n - 1 }$</li>
</ul>
<center><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308072106416.png" alt="image-20230802160529386" style="zoom:50%;" /><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308021605987.png" alt="image-20230802160545936" style="zoom: 50%;" /></center>

<p>先求<strong>路径总数</strong>：在 $2n$ 次移动中选 $n$ 次向右移动，即 $C_{2n}^{m}$ ，再求非法路径，即越过对角线的路径；</p>
<p>再求<strong>非法路径</strong>，即越过对角线的路径：</p>
<p>把 $y&#x3D;x+1$ 这条线画出来，碰到即说明是一条非法路径。所有的非法路径与这条线有至少一个交点，把第一个交点设为 $(a,a+1)$ ；</p>
<p>把 $(a,a+1)$ 之后的路径全部按照 $y&#x3D;x+1$ 这条线对称过去，这样，最后的终点就会变成 <strong>$(n-1,n+1)$</strong> ；</p>
<p>所有非法路径对称后都<strong>唯一</strong>对应着一条到 $(n-1,n+1)$ 的路径，所以非法路径数就是 $C _ { 2 n } ^ { n - 1 }$ ,合法路径数就是 $C _ { 2 n } ^ { n } - C _ { 2 n } ^ { n - 1 }$ 。</p>
<p> $\begin{align}H_{n}&amp;&#x3D;C _ { 2 n } ^ { n } - C _ { 2 n } ^ { n - 1 } \&amp;&#x3D; \frac { ( 2 n ) ! } { n ! n ! } - \frac { ( 2 n ) ! } { ( n + 1 ) ! ( n - 1 ) ! }\&amp;&#x3D; \frac { ( 2 n ) ! } { n ! ( n - 1 ) ! } ( \frac { 1 } { n } - \frac { 1 } { n + 1 } ) \&amp;&#x3D; \frac { ( 2 n ) ! } { n ! n ! ( n + 1 ) } \&amp;&#x3D; \frac { 1 } { n + 1 } C _ { 2 n } ^ { n }\end{align}$ </p>
<p><em><strong>Catalan应用</strong></em></p>
<ol>
<li><p>一个有 $n$ 个 $0$ 和 $n$ 个 $1$ 组成的字串，且所有的前缀字串皆满足 $1$ 的个数不超过 $0$ 的个数。这样的字串个数有多少？</p>
</li>
<li><p>包含 $n$ 组括号的合法运算式的个数有多少？</p>
</li>
<li><p>一个栈的进栈序列为 $1,2,3，…，n$ ，有多少个不同的出栈序列？</p>
</li>
<li><p>$n$ 个结点可构造多少个不同的二叉树？</p>
</li>
</ol>
<p>   <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/3402.html">n个结点构造多少种树</a> </p>
<ol start="5">
<li><p>在圆上选择 $2$ 个点，将这些点成对连接起来使得所得到的 $n$ 条弦不相交的方法数？</p>
</li>
<li><p>通过连结顶点而将 $n+2$ 边的凸多边形分成n个三角形的方法数？</p>
</li>
</ol>
<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><h3 id="集合的并"><a href="#集合的并" class="headerlink" title="集合的并"></a>集合的并</h3><p>设 $U$ 中元素有 $n$ 种不同的属性，第 $i$ 种属性称为 $P$ ，拥有属性 $P$ 的元素构成集合 $S$ ，那么$\begin{aligned}<br>\left|\bigcup_{i&#x3D;1}^{n} S_{i}\right|&#x3D; &amp; \sum_{i}\left|S_{i}\right|-\sum_{i&lt;j}\left|S_{i} \cap S_{j}\right|+\sum_{i&lt;j&lt;k}\left|S_{i} \cap S_{j} \cap S_{k}\right|-\cdots<br> +(-1)^{m-1} \sum_{a_i&lt;a_{i+1}}\left|\bigcap_{i&#x3D;1}^{m} S_{a_i}\right|+\cdots+(-1)^{n-1}\left|S_{1} \cap \cdots \cap S_{n}\right|<br>\end{aligned}$</p>
<p>即：$\begin{aligned}<br>\left|\bigcup_{i&#x3D;1}^{n} S_{i}\right|&#x3D; \sum^n_{m-1} (-1)^{m-1} \sum_{a_i&lt;a_{i+1}}\left| \bigcap_{i&#x3D;1}^{m} S_{a_i}\right|<br>\end{aligned}$</p>
<p><strong style="color:red;">集合的并等于集合的交的交错和（奇正偶负）</strong> </p>
<p>使用的<strong>二进制位</strong>来表示每个集合<strong>选（1）</strong>与<strong>不选（0）</strong>的状态</p>
<p><strong>Q</strong>：给定一个整数 $n$ 和 $m$ 个不同的质数 $p _ { 1 } , p _ { 2 } , \cdots , p _ { m }$ ，求 $1\to n$ 中能被 $p _ { 1 } , p _ { 2 } , \cdots , p _ { m }$ 中的至少一个数整除的数有多少个？其中$m \leq 16 , n , p _ { i } \leq 10 ^ { 9 }$ </p>
<p><strong>A</strong>：交集的大小等于 $n$ 除以质数的乘积。</p>
<p>​	$| S _ { 1 } | &#x3D; \frac { n } { p _ { 1 } }$ ，$ | S _ { 1 } \cap S _ { 2 } | &#x3D; \frac { n } { p _ { 1 } + p _ { 2 } } $，$ | S _ { 1 } \cap S _ { 2 } \cap S _ { 3 } | &#x3D; \frac { n } { p _ { 1 }+ {  p _ { 2 } + p _ { 3 } } }$ </p>
<p>​	若有 $3$ 个质数，就需要 $3$ 个二进制位来表示所有状态</p>
<p>​	$001 \rightarrow S _ { 1 }$ ， $010 \rightarrow S _ { 2 }$ ，$100 \rightarrow S _ { 3 }$ </p>
<p>​	$011 \rightarrow S _ { 1 } \cap S _ { 2 }$ ， $101 \rightarrow S _ { 1 } \cap S _ { 3 }$ ， $011 \rightarrow S _ { 2 }\cap S _ { 3 } $ </p>
<p>​	$111 \rightarrow S _ { 1 } \cap S _ { 2 }\cap S_{3}$ ， $000 \rightarrow \varnothing$ </p>
<p>​	我们只要枚举从 $001$ 到 $111$ 的<strong>每个状态</strong>，就可以计算出全部交集的<strong>交错和</strong>。</p>
<p>​	时间复杂度： $O ( m * 2 ^ { m } )$ </p>
<pre><code class="C++">// 此代码需要针对特定问题研究
typedef long long ll;
const int N = 20;
int n, m, prim[N];
// n代表范围
// 一共有m属性
// 容斥原理
int calc()
&#123;
    // 集合元素个数
    int res = 0;
    // 枚举状态 一共有 1 &lt;&lt; m 种状态，第0位~第m-1位都表示一种状态
    for (int i = 1; i &lt; 1 &lt;&lt; m; i++)
    &#123;
        // t代表集合元素个数，sign代表符号
        int t = 1, sign = -1;
        // 过滤状态
        //  注意j从0开始，查看每个集合的状态
        for (int j = 0; j &lt; m; j++)
            // 状态为1代表选中
            if (i &amp; 1 &lt;&lt; j)
            &#123;
                // 比n大，直接为0
                if ((ll)t * prim[j] &gt; n)
                &#123;
                    t = 0;
                    break;
                &#125;
                // 质数的积
                t *= prim[j];
                // 符号位相反
                sign = -sign;
            &#125;
        // t不为0，计算答案
        if (t)
            res += n / t * sign; // 交集的和
    &#125;
    return res;
&#125;
</code></pre>
<h3 id="集合的交"><a href="#集合的交" class="headerlink" title="集合的交"></a>集合的交</h3><p><strong style="color:red;">集合的交等于全集减去补集的并</strong>，<strong>补集的并</strong>使用<strong>容斥原理</strong>求解</p>
<p>即 $\begin{aligned}<br>\left|\bigcap_{i&#x3D;1}^{n} S_{i}\right|&#x3D; \left|U\right|- \left| \bigcup_{i&#x3D;1}^{m} \overline {S_{i}}\right|<br>\end{aligned}$ </p>
<p>本质还是求集合的并，只是转换了思维；</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1450">洛谷 P1450 硬币购物</a></p>
<p><em>容斥原理思路</em></p>
<pre><code class="c++">// 此代码需要针对特定问题研究
const int N = 16;
typedef long long ll;
// 容斥原理
ll calc()
&#123;
    // 集合元素个数
    ll res = 0;
    // 枚举状态 一共有 1 &lt;&lt; m 种状态，第0位~第m-1位都表示一种状态
    for (int i = 1; i &lt; 1 &lt;&lt; N; i++)
    &#123;
        // t代表并集状态，sign代表符号
        ll t = ......, sign = -1;
        // 过滤状态
        //  注意j从0开始，查看每个集合的状态
        for (int j = 0; j &lt; N; j++)
            // 状态为1代表选中
            if (i &amp; 1 &lt;&lt; j)
            &#123;
                // 更新并集状态
                // t......;
                // 符号位相反
                sign = -sign;
            &#125;
        // 答案更新条件
        if (......)
            res......;
    &#125;
    return ......;
&#125;
</code></pre>
<h2 id="整除分块"><a href="#整除分块" class="headerlink" title="整除分块"></a>整除分块</h2><p><em><strong>时间复杂度： $O(\sqrt n)$</strong></em> </p>
<ul>
<li>求 $\sum\limits _ { i &#x3D; 1 } ^ { n } \lfloor \dfrac { n } { i } \rfloor$ ；</li>
</ul>
<p><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308021715299.png" alt="image-20230802171523229"></p>
<p><strong>性质1</strong>：<strong>分块的块数 $≤2\lfloor\sqrt n\rfloor$</strong>  <em>保证时间复杂度</em></p>
<p>​	当 $i \le \lfloor\sqrt n\rfloor $ 时，$\lfloor \dfrac{n}{i} \rfloor$ 有 $\sqrt n$ 种取值</p>
<p>​	当 $i \le \lfloor\sqrt n\rfloor $ 时， $\lfloor \dfrac{n}{i} \rfloor \le \lfloor\sqrt n\rfloor$ ，$\lfloor \dfrac{n}{i} \rfloor$ 至多有 $\lfloor\sqrt n\rfloor$ 种取值；</p>
<p><strong>性质2</strong>： <strong>$i$ 所在块的右端点为 $\lfloor \dfrac{n}{\lfloor \dfrac{n}{i} \rfloor} \rfloor$</strong>  <em>计算方法</em></p>
<p>​	 $i$ 所在块的值 $k&#x3D;\lfloor \dfrac{n}{i} \rfloor$ ，则 $k \le \dfrac{n}{i}$ ，则  $\lfloor \dfrac{n}{k} \rfloor \ge \lfloor \dfrac{n}{\lfloor \dfrac{n}{i} \rfloor} \rfloor&#x3D;\lfloor i \rfloor &#x3D;i$ ；</p>
<p>​	所以 $i_{max}&#x3D;\lfloor \dfrac{n}{k} \rfloor &#x3D; \lfloor \dfrac{n}{\lfloor \dfrac{n}{i} \rfloor} \rfloor$ ；</p>
<p>​	代码实现 <code>r=n/(n/l)</code> </p>
<ul>
<li>求 $\sum\limits _ { i &#x3D; 1 } ^ { n } f(i)\cdot\lfloor \dfrac { n } { i } \rfloor$ ；</li>
</ul>
<p>先预处理出 $f(i)$ 的前缀和  $s(i)&#x3D;\sum ^i_{j&#x3D;1}f(j))$ ，再枚举每一块 $[l,r]$ ，累加每块的贡献。</p>
<pre><code class="c++">// s[]为前缀和
// l=r+1为跳到下一块
for (int l = 1; l &lt;= n; l = r + 1)
&#123;
    // 注意 n/l==0 特判情况
    // if (k / 1 = 0)
    //     break;
    r = n / (n / l);
    // 当k&gt;n时候，可能会多算
    // r min(k / (k / 1), n);
    res += (s(r) - s(l - 1)) * (n / l);
&#125;
</code></pre>
<h2 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h2><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">普通生成函数</th>
<th align="center">指数生成函数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">定义</td>
<td align="center">$F ( x ) &#x3D; \sum a _ { n } x ^ { n }$</td>
<td align="center">$F ( x ) &#x3D; \sum a _ { n } \dfrac{x ^ { n }}{n!}$</td>
</tr>
<tr>
<td align="center">卷积</td>
<td align="center">$\sum \limits _ { i \ge 0 } a _ { i } x ^ { i } \sum \limits _ { j \ge 0 } b _ { j } x ^ { j } &#x3D; \sum \limits _ { n \ge 0 } x ^ { n } \sum  \limits_ { i &#x3D; 0 } ^ { n } a _ { i } b _ { n - i }$</td>
<td align="center">$\sum\limits _ { i \ge 0 } a _ { i } \dfrac { x ^ { i } } { i ! } \sum\limits _ { j \ge 0 } b _ { j  } \dfrac { x^j }{j!} &#x3D; \sum\limits _ { n \ge 0 } \dfrac { x ^ { n } }{n!} \sum\limits _ { i &#x3D; 0 } ^ { n } \dfrac { n ! } { i ! ( n - i ) ! } a _ { i } b _ { n - i }$</td>
</tr>
<tr>
<td align="center">构造</td>
<td align="center">$( 1 + x ^ { 1 } + \cdots + x ^ { a _ { 1 } } ) \cdots ( 1 + x ^ { 1 } + \cdots + x ^ { a _ { n } } )$</td>
<td align="center">$( 1 + \dfrac { x ^ { 1 } } { 1 ! } + \dfrac { x ^ { 2 } } { 2 ! } + \cdots + \dfrac { x ^ { a _ { 1 } } } { a _ { 1 } ! } )\cdots ( 1 + \dfrac { x ^ { 1 } } { 1 ! } + \dfrac { x ^ { 2 } } { 2 ! } + \cdots + \dfrac { x ^ { a _ { n } } } { a _ { n} ! } )$</td>
</tr>
<tr>
<td align="center">用途</td>
<td align="center">多重集组合数</td>
<td align="center">多重集排列数</td>
</tr>
<tr>
<td align="center">结果</td>
<td align="center">$x^m$ 的系数即组合数</td>
<td align="center">$\dfrac{x^m}{m!}$ 的系数即排列数</td>
</tr>
</tbody></table>
<h3 id="普通生成函数"><a href="#普通生成函数" class="headerlink" title="普通生成函数"></a>普通生成函数</h3><p> $F ( x ) &#x3D; \sum _ { n \geq 0 } a _ { n } x ^ { n }$ </p>
<p><strong>加减操作（必须数量相同）：</strong></p>
<p> $ \begin{align}  F ( x ) \pm G ( x ) &amp;&#x3D; \sum _ { i \ge 0 } a _ { i } x ^ { i } \pm \sum _ { j \geq 0 } b _ { j } x ^ { j }  \ &amp; &#x3D; \sum _ { n \geq 0 } ( a _ { n } + b _ { n } ) x ^ { n } \end{align} $ </p>
<p><strong>乘法操作（卷积）：</strong></p>
<p> $\begin{aligned}<br>F(x) G(x) &amp; &#x3D;\sum_{i \geq 0} a_{i} x^{i} \sum_{j \geq 0} b_{j} x^{j} \<br>&amp; &#x3D;\sum_{n \geq 0} x^{n} \sum_{i&#x3D;0}^{n} a_{i} b_{n-i} \quad(\text { 令 } i+j&#x3D;n)<br>\end{aligned}$ </p>
<p> 例如 $n&#x3D;3$ ，则 $x^3$ 的系数为 $a _ { 0 } b _ { 3 } + a _ { 1 } b _ { 2 } + a _ { 2 } b _ { 1 } + a _ { 3 } b _ { 0 }$ </p>
<p>因此 $F(x)G(x)$ 是序列 $\lt \sum _ { i &#x3D; 0 } ^ { n } a _ { i } b _ { n - i } \gt$ 的普通生成函数。</p>
<p><em>解决<strong>多重集组合数</strong>问题</em></p>
<p><strong>问题</strong>：有 $n$ 种物品，每种物品有 $a_i$ 个，问取 $m$ 个物品的<strong>组合数</strong>？</p>
<p>设从每种物品中取 $b_i$ 个， $0 \le b_i \le a_i$，对于一组选定的 $b_i$ 进行组合的方案数为 $1$。</p>
<p>例如，取 $3$ 个 $A$ 、 $1$ 个 $B$ 的方案就是 ${AAAB}$ ；取 $2$ 个 $A$ 、 $2$ 个 $B$ 的方案就是 ${AABB}$ 。</p>
<p>那么，所有满足 $b_1+b_2+\cdots+b_n&#x3D;m$ 的方案之和，即答案。</p>
<p><strong>构造普通生成函数</strong></p>
<p>第 $1$ 种物品的生成函数为 $( 1 + x ^ { 1 } + x ^ { 2 } + \cdots + x ^ { a _ { 1 } } )$ ，第 $n$ 种物品的生成函数为 $( 1 + x ^ { 1 } + x ^ { 2 } + \cdots + x ^ { a _ { n } } )$ </p>
<p>即求 $x^m$ 的系数。</p>
<p><em>注意：<strong>指数</strong>即<strong>物品个数</strong>，<strong>系数</strong>即<strong>组合数</strong>。</em>灵活选取<strong>指数前面的系数</strong>！</p>
<p><strong>问题</strong>：有 $n$ 种水果，每种水果选购的个数在 $[a_i,b_i]$ 之间问，买 $m$ 个水果有多少种购买方案？</p>
<p>转化：构造生成函数 $( x ^ { a_1 } + \cdots + x ^ { b _ { 1 } } ) ( x ^ { a _ { 2 } } + \cdots + x ^ { b _ { 2 } } ) \cdots ( x ^  {a _ n } + \cdots + x ^ { b _ { n }   })$ ，求 $x^m$ 的系数。</p>
<p>代码模拟<strong>括号的展开</strong>。</p>
<pre><code class="c++">int n, m;           // n代表物品种数，m代表最终选取的个数
int a[110], b[110]; // 存幂次 幂次范围为a[i]~b[i]  下标从1开始
int C[110], D[210]; // 存系数 C为系数结果 D为辅助数组

int calc()
&#123;
    // 初始化C[i]，D[i]
    for (int i = 0; i &lt;= m; ++i)
        C[i] = D[i] = 0;
    // 给C填充第1项的系数
    for (int i = a[1]; i &lt;= b[1]; ++i)
        C[i] = 1;
    // 从第2项开始枚举
    for (int i = 2; i &lt;= n; ++i)
    &#123;
        // 计算x^j*x^k的系数 x^j系数是在C[j]存储，只需要计算到C[m]，大于m的对于结果没有影响
        for (int j = 0; j &lt;= m; ++j)
            // 当前括号 遍历x^k   改变指数的系数在这里！
            for (int k = a[i]; k &lt;= b[i]; ++k)
                // x^j*x^k系数相乘，会得到新的x^(j+k)的系数
                D[j + k] += C[j];
        // 转存C，清空D
        for (int j = 0; j &lt;= m; ++j)
            C[j] = D[j], D[j] = 0;
    &#125;
    // 返回选m的结果
    return C[m];
&#125;
</code></pre>
<h3 id="指数生成函数"><a href="#指数生成函数" class="headerlink" title="指数生成函数"></a>指数生成函数</h3><p> $F ( x ) &#x3D; \sum _ {n \ge 0} a _ { n ! } \frac { x ^ { n } } { n ! }$ </p>
<p>序列 $&lt;1,1,1,\cdots&gt;$ 的指数生成函数是 $1 + \dfrac { x } { 1 ! } + \dfrac { x ^ { 2 } } { 2 ! } + \dfrac { x ^ { 3 } } { 3 ! } + \cdots &#x3D; \sum \limits _ { n \geq 0 } ^ { x ^ { n } } &#x3D; e ^ { x }$ </p>
<p>序列 $&lt;1 , p , p ^ { 2 },\cdots &gt;$ 的指数生成函数是 $1 + p \dfrac { x } { 1 ! } + p ^ { 2 } \dfrac { x ^ { 2 } } { 2 ! } + p ^ { 3 } \dfrac { x ^ { 3 } } { 3 ! } + \cdots &#x3D; \sum _ { n \geq 0 } p ^ { n } \dfrac { x ^ { n } } { n ! } &#x3D; e ^ { p x }$ </p>
<p><strong>加减操作（必须数量相同）：</strong></p>
<p> $\left. \begin{align}  F ( x ) \pm G ( x ) &amp;&#x3D; \sum _ { i \geq 0 } a _ { i } \frac { x ^ { i } } { i! } \pm \sum _ { j \geq 0 } b _ { j } \frac { x ^ { j } } { j ! }  \ &amp;&#x3D; \sum _ { n \geq 0 } ( a _ { n } + b _ { n } ) \frac { x ^ { n } } { n ! }  \end{align} \right.$ </p>
<p>因此 $F(x)±G(x)$ 是序列 $&lt;a_n±b_n&gt;$ 的指数生成函数。</p>
<p> $ \begin{align} F ( x ) G ( x ) &amp; &#x3D; \sum \limits_ { i \ge 0 } a _ { i } \dfrac  { x ^ { i } }{i!} \sum \limits _ { j \geq 0 } b _ { j } \dfrac { x ^ { j } } { j ! } \&amp;&#x3D; \sum _ { n \ge 0 } x ^ { n } \sum _ { i &#x3D; 0 } ^ { n } a _ { i } b _ { n - i } \dfrac { 1 } { i ! ( n - i ) ! } \&amp;&#x3D; \sum _ { n &#x3D; 0 } \frac { x ^ { n } } { n ! } \sum _ { i &#x3D; 0 } ^ { n } \frac { n ! } { i ! ( n - i ) ! } a _ { i } b _ { n - i } \&amp;&#x3D; \sum _ { n \geq 0 } \frac { x ^ { n } } { n ! } \sum _ { i &#x3D; 0 } ^ { n } C _ { n } ^ { i } a _ { i } b _ { n - i }\end{align} $ </p>
<p>因此 $F(x)G(x)$ 是序列 $\lt \sum _ { i &#x3D; 0 } ^ { n } C _ { n } ^ { i } a _ { i } b _ { n - i } \gt$ 的指数生成函数。</p>
<p><em>解决<strong>多重集排列数</strong>问题</em></p>
<p><strong>问题</strong>：有 $n$ 种物品，每种物品有 $a_i$ 个，问取 $m$ 个物品的<strong>排列数</strong>？</p>
<p>设从每种物品中取 $b _ { i }$ 个，$0 \leq b _ { i } \leq a _ { i }$ ，$m &#x3D; \sum _ { i &#x3D; 1 } ^ { n } b _ { i }$ ， 对于一组选定的 $b _ { i }$ 进行排列的方案数为 $\dfrac { m ! } { b _ { 1}  !b _ { 2 }! \cdots b _ { n } !}$ </p>
<p>若 $m$ 个物品互不相同，其排列数为 $m!$ ，分母就是对每种相同物品的排列数去重。</p>
<p>例如</p>
<p>取 $3$ 个 $A$ 、 $1$ 个 $B$ 的排列数为 $\dfrac { 4 ! } { 3 ! 1 ! } &#x3D; \dfrac { 24 } { 6 } &#x3D; 4$ ，即 $&lt;!–swig￼0–&gt;{i^{x}} \sum_{j&#x3D;1}^{\infty} \frac{b_{j}}{j^{x}} \<br>&#x3D; &amp; \left(\frac{a_{1}}{1^{x}}+\frac{a_{2}}{2^{x}}+\frac{a_{3}}{3^{x}}+\frac{a_{4}}{4^{x}}+\cdots\right)\left(\frac{b_{1}}{1^{x}}+\frac{b_{2}}{2^{x}}+\frac{b_{3}}{3^{x}}+\frac{b_{4}}{4^{x}}+\cdots\right) \<br>&#x3D; &amp; \frac{a_{1} b_{1}}{1^{x}}+\frac{a_{1} b_{2}+a_{2} b_{1}}{2^{x}}+\frac{a_{1} b_{3}+a_{3} b_{1}}{3^{x}}+\frac{a_{1} b_{4}+a_{2} b_{2}+a_{4} b_{1}}{4^{x}}+\cdots \<br>&#x3D; &amp; \sum_{n&#x3D;1}^{\infty} \frac{1}{n^{x}} \sum_{d \mid n} a_{d} \frac{b_{n}}{d}<br>\end{aligned}$ </p>
<p> $\dfrac{1}{6^x} $ 的系数 $a _ { 1 } b _ { 6 } + a _ { 2 } b _ { 3 } + a _ { 3 } b _ { 2 } + a _ { 6 } b _ { 1 }$ （枚举 $6$ 的约数）</p>
<p><strong>欧拉函数</strong></p>
<p> $\varphi ( n ) &#x3D; \sum\limits _ { i &#x3D; 1 } ^ { n } [ \gcd ( i , n ) &#x3D; 1 ]$ </p>
<p>性质： $\sum\limits _ { d | n } \varphi ( d ) &#x3D; n$ </p>
<img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308072149337.png" alt="image-20230807214700821" style="zoom:50%;" />

<p><strong>莫比乌斯函数</strong></p>
<p>$\begin{align*}\begin{split}\mu(n)&#x3D; \left {\begin{array}{lr}1,&amp; n&#x3D;1\0,&amp; n含相同质因子\(-1)^s,&amp; s为n的不同质因子的个数\end{array}\right.\end{split}\end{align*}$ </p>
<p>性质： $\sum\limits _ { d | n } \mu( d ) &#x3D; [ n &#x3D; 1 ]$  </p>
<p><img src="https://gitee.com/lumosion/pic-go/raw/master/icpc/Figure/202308102118189.png" alt="image-20230810211848076"></p>
<p>证明： $n&#x3D;1$ 时， $d&#x3D;1$ ， $\mu(1)&#x3D;1$ </p>
<p>当 $n&gt;1$ 时， $n &#x3D; p _ { 1 } ^ { \alpha _ { 1 } } p _ { 2 } ^ { \alpha _ { 2 } } \cdots p _ { s } ^ { \alpha _ { s } }$ ，令 $n ^ { \prime } &#x3D; p _ { 1 } p _ { 2 } \cdots p _ { s }$ </p>
<p> $\sum \limits _ { d |n } \mu ( d ) &#x3D; \sum \limits _ { d | n ^ { \prime } } \mu ( d )$ ，因为质因子重复会导致 $\mu(d)$ 为 $0$ 。</p>
<p>约数由质因子或乘积构成，根据容斥原理</p>
<p>不取任何质因子的方案数： $C_s^0$ </p>
<p>取 $1$ 个质因子的方案数：$C_s^1$ </p>
<p>取 $2$ 个质因子的方案数：$C_s^2$ </p>
<p>$\dots$ </p>
<p>$\begin{aligned}\sum \limits _ { d |n } \mu ( d ) &amp;&#x3D; \sum \limits _ { d | n ^ { \prime } } \mu ( d )\&amp;&#x3D; C^0_s + ( - 1 ) C^1_s + ( - 1 ) ^ { 2 } C^2_s + \cdots + ( - 1 ) ^ { s } C^s_s \&amp;&#x3D;(1+(-1))^{s} \ &amp;&#x3D;0\end{aligned} $</p>
<p><strong style="color:red;">欧拉函数和莫比乌斯函数的联系：$\sum \limits _ { d | n } \mu ( d ) \dfrac { n } { d } &#x3D; \varphi ( n )$ </strong></p>
<p>证明： $n&#x3D;1$ 时， $d&#x3D;1$ ， $\mu(1)&#x3D;\varphi(1)&#x3D;1$  </p>
<p>当 $n&gt;1$ 时， $n &#x3D; p _ { 1 } ^ { \alpha _ { 1 } } p _ { 2 } ^ { \alpha _ { 2 } } \cdots p _ { s } ^ { \alpha _ { s } }$ ，令 $n ^ { \prime } &#x3D; p _ { 1 } p _ { 2 } \cdots p _ { s }$ </p>
<p> $\sum \limits _ { d |n } \mu ( d ) \dfrac{n}{d}&#x3D; n\sum \limits _ { d | n ^ { \prime } }\dfrac{ \mu ( d )}{d}$ ，因为质因子重复会导致 $\mu(d)$ 为 $0$ 。</p>
<p> $\begin{align}\sum \limits _ { d |n } \mu ( d ) \dfrac{n}{d}&amp;&#x3D; n\sum \limits _ { d | n ^ { \prime } }\dfrac{ \mu ( d )}{d} \<br> &amp; &#x3D; n\left(1-\left(\frac{1}{p_{1}}+\cdots+\frac{1}{p_{s}}\right)+\left(\frac{1}{p_{1} p_{2}}+\cdots+\frac{1}{p_{s-1} p_{s}}\right)-\cdots\right) \ &amp; &#x3D; n\left(1-\frac{1}{p_{1}}\right)\left(1-\frac{1}{p_{2}}\right) \cdots\left(1-\frac{1}{p_{s}}\right) \ &amp; &#x3D; \varphi(n)<br>\end{align}$ </p>
<p><strong>狄利克雷卷积</strong></p>
<p><strong>定义</strong>： $f ( n ) $ ， $ g ( n )$ 是两个积性函数，</p>
<p>$( f * g ) ( n ) &#x3D; \sum \limits_ { d | _ { n } } f ( d ) g ( \dfrac { n } { d } ) &#x3D; \sum\limits _ { d | n } f ( \dfrac { n } { d } ) g ( d )$ </p>
<p><strong>规律</strong>：</p>
<ol>
<li>交换律： $f<em>g&#x3D;g</em>f$ </li>
<li>结合律： $(f<em>g)<em>h&#x3D;f</em>(g</em>h)$</li>
<li>分配律： $(f+g)<em>h&#x3D;f</em>h+g*h$</li>
</ol>
<p><strong>三个常用函数</strong>：</p>
<ol>
<li>元函数： $\varepsilon ( n ) &#x3D; [ n &#x3D; 1 ]$ </li>
<li>常数函数： $1(n)&#x3D;1$</li>
<li>恒等函数： $id(n)&#x3D;x$</li>
</ol>
<p><strong>常用函数</strong>：</p>
<ol>
<li>$\sum\limits _ { d | n } \mu( d ) &#x3D; [ n &#x3D; 1 ]\Leftrightarrow \mu*1&#x3D;\varepsilon$ </li>
<li>$\sum\limits _ { d | n } \varphi ( d ) &#x3D; n \Leftrightarrow \varphi*1&#x3D;id$ </li>
<li>$\sum \limits _ { d | n } \mu ( d ) \dfrac { n } { d } &#x3D; \varphi ( n ) \Leftrightarrow \mu*id&#x3D;\varphi$ </li>
<li>$f*\varepsilon&#x3D;f$ </li>
<li>$f*1\neq f$</li>
</ol>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2023 - 2023 LumosionのBlog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Lumosion
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

            </div>
            
            <transition name="fade">
                <div id="preview" ref="preview" v-show="previewShow">
                    <img id="preview-content" ref="previewContent" />
                </div>
            </transition>
            
        </div>
        <script src="/js/main.js"></script>
        
        




        
    </body>
</html>
